// Importamos los clientes de Google Cloud necesarios
import { Firestore } from "@google-cloud/firestore";
import { VertexAI } from "@google-cloud/vertexai";
import fs from "fs";
import { v1 } from "@google-cloud/discoveryengine";
const discoveryengineClient = new v1.SearchServiceClient();

// Leemos las variables de entorno necesarias
//const projectId = process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID;
//const location = process.env.VERTEX_AI_LOCATION || "us-east1"; // Regi√≥n por defecto
const firestoreDatabaseId = process.env.FIRESTORE_DATABASE_ID || "(default)";
//const vertexAiSearchDataStoreId = process.env.VERTEX_AI_SEARCH_DATA_STORE_ID;
const projectId = 'deudas-inmobiliarias';
const location = process.env.VERTEX_AI_LOCATION || "us-east1"; // Usa la regi√≥n de tu Data Store
const vertexAiSearchDataStoreId = 'inmuebles_1748938854943';


import { auth } from 'google-auth-library';

/*const credentialsJSON = process.env.GOOGLE_APPLICATION_CREDENTIALS_JSON;

if (!credentialsJSON) {
  throw new Error("‚ùå Falta la variable de entorno GOOGLE_APPLICATION_CREDENTIALS_JSON.");
}

const auth = new GoogleAuth({
  credentials: JSON.parse(credentialsJSON),
  scopes: ['https://www.googleapis.com/auth/cloud-platform'],
});

const authClient = await auth.getClient();
const project = await auth.getProjectId();
console.log("‚úÖ Autenticado en proyecto:", project);*/


console.log(
  "GOOGLE_APPLICATION_CREDENTIALS:",
  process.env.GOOGLE_APPLICATION_CREDENTIALS
);

// Comprobamos si el archivo de credenciales existe si la variable est√° definida
if (process.env.GOOGLE_APPLICATION_CREDENTIALS && !fs.existsSync(process.env.GOOGLE_APPLICATION_CREDENTIALS)) {
  console.error(
    "‚ùå Archivo de credenciales no encontrado. Verifica la ruta GOOGLE_APPLICATION_CREDENTIALS."
  );
  // Dependiendo de tu configuraci√≥n, podr√≠as querer lanzar un error fatal aqu√≠,
  // pero por ahora solo lo registramos.
}

// Verificamos que las variables clave est√©n definidas
if (
  !projectId ||
  !vertexAiSearchDataStoreId
  // Eliminamos la verificaci√≥n de GOOGLE_APPLICATION_CREDENTIALS como obligatoria aqu√≠
  // ya que el cliente auth.getClient() deber√≠a manejar la autenticaci√≥n
) {
  console.error("‚ùå Faltan variables de entorno requeridas: NEXT_PUBLIC_FIREBASE_PROJECT_ID o VERTEX_AI_SEARCH_DATA_STORE_ID.");
  // En producci√≥n deber√≠as retornar un error HTTP aqu√≠ o manejar de forma segura.
}

// üî• Inicializamos el cliente de Firestore (Puede que no lo necesites para este endpoint espec√≠fico,
// pero lo mantengo si lo usas en otras partes del c√≥digo)
const firestore = new Firestore({
  projectId: projectId,
  databaseId: firestoreDatabaseId,
});

// ü§ñ Inicializamos el cliente de Vertex AI
const vertex_ai = new VertexAI({
  project: projectId,
  location: location,
});

// üì¶ Construimos el nombre completo del data store para las b√∫squedas
const dataStoreName = `projects/${projectId}/locations/global/collections/default_collection/dataStores/${vertexAiSearchDataStoreId}`;

// ‚ú® Creamos el modelo generativo Gemini-Pro
const generativeModel = vertex_ai.getGenerativeModel({
  model: 'gemini-2.0-flash-lite-001',
});


// Handler para el endpoint /api/chat (Next.js o API Route en App Router)
export async function POST(req) {
  const { query: userQuery } = await req.json();

  // Saludo inicial o mensaje vac√≠o
  if (userQuery.trim() === "" || userQuery.toLowerCase().includes("hola")) {
    const bienvenida = `¬°Hola! üëã Un placer saludarte.
¬øEn qu√© puedo ayudarte hoy a encontrar una propiedad? ¬øTienes alguna idea de lo que est√°s buscando? ¬øPor ejemplo, te interesa comprar, alquilar, en qu√© zona te gustar√≠a, qu√© tipo de propiedad tienes en mente (piso, casa, local comercial...)? Cu√©ntame un poco m√°s sobre tus necesidades para poder ayudarte mejor. üòä`;

    return new Response(
      JSON.stringify({
        conversationalResponse: bienvenida,
        propertyResults: [],
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  if (!userQuery) {
    return new Response(
      JSON.stringify({ error: "Falta la consulta del usuario en el cuerpo de la solicitud" }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  let conversationalResponse = "Lo siento, no pude procesar tu solicitud.";
  let propertyResults = [];
  let geminiResponseJson = null; // Variable para almacenar el JSON parseado de Gemini
  let action = "clarify"; // Por defecto si algo falla con Gemini, pedimos clarificaci√≥n
  let clarificationQuestion = "Por favor, ¬øpodr√≠as darme m√°s detalles sobre lo que buscas?"; // Pregunta de fallback

  try {
    // üß† Paso 1: Gemini interpreta el query completo y decide la acci√≥n
    // Usamos backticks para un prompt multilinea m√°s limpio
    const prompt = `Analyze the user's request for real estate properties. Your goal is to determine if a direct search can be performed using Vertex AI Search or if clarification from the user is needed to proceed effectively. You must provide a structured JSON response according to the specified format.

**Instructions:**
1. Read the user's message carefully to understand their intent and requirements regarding real estate.
2. Identify all key search criteria and relevant concepts mentioned, such as locations (specific cities, regions, neighborhoods, coastal areas like "costa de Huelva", or broader areas like "Andaluc√≠a"), property types (houses, apartments, commercial), price ranges, number of rooms/bedrooms/bathrooms, specific features (parking, proximity to beach or coast), and any other relevant intentions or criteria (e.g., "investment", "profitability", specific procedures like "auction", "rentable").
3. Decide the best course of action:
    - If you have enough clear and specific information to formulate a meaningful search query for Vertex AI Search AND potentially some strict filters (like a clear price range, exact number of bedrooms, or a very specific property type), set \`action\` to \`"search"\`.
    - If the request is ambiguous, too broad, lacks necessary specific details for an effective search (e.g., vague location, very general criteria like "inversi√≥n" without more context), or if you need to understand the user's needs better to provide relevant results, set \`action\` to \`"clarify"\` and formulate a precise \`clarificationQuestion\` for the user.
4. Structure your response as a JSON object with the following fields. **Ensure the output is ONLY the JSON object and nothing else.**
    - \`action\` (string): Must be either \`"search"\` or \`"clarify"\`.
    - \`searchQuery\` (string): If \`action\` is \`"search"\`, provide an optimized natural language query string for Vertex AI Search that captures the essence of the user's request, including locations, property types, and key concepts that Vertex AI Search's natural language processing can handle (e.g., "casas en la playa Huelva", "inmuebles rentables Madrid"). If \`action\` is \`"clarify"\`, this field must be an empty string \`""\`.
    - \`filters\` (object): If \`action\` is \`"search"\`, provide a JSON object containing key-value pairs for specific, strict criteria that can be directly mapped to filterable fields in the Data Store. **Only include fields here if the user provided a clear, quantifiable or strictly categorical value that is suitable for a precise filter.** Do NOT include broad concepts or general locations in filters. Examples of suitable filter criteria keys (use these keys if applicable): \`minPrice\`, \`maxPrice\`, \`bedrooms\`, \`bathrooms\`, \`has_parking\` (boolean/string), \`propertyType\` (specific type like "Apartamento", "Casa"). If no clear filterable parameters are found, this must be an empty object \`{}\`.
    - \`clarificationQuestion\` (string): If \`action\` is \`"clarify"\`, provide a clear, concise, and friendly question in **Spanish** to the user to gather the missing specific information needed to perform a search. If \`action\` is \`"search"\`, this field must be an empty string \`""\`.
    - \`extractedConcepts\` (array of strings): List any key concepts or criteria identified in the user's query that might be relevant, including locations (even if general), property types, features, and intentions (like "inversi√≥n", "rentabilidad", "playa", "costa", "Andaluc√≠a"). This field is for context and is not used directly for filtering.

**User Query:** "${userQuery}"

**JSON Output:**
\`\`\`json
{
  // Your JSON response here
}
\`\`\`
`;

    const geminiResponse = await generativeModel.generateContent(prompt);
    const geminiText = geminiResponse.response.candidates[0]?.content?.parts[0]?.text;

    console.log('üîç Respuesta cruda desde Vertex AI (Gemini - An√°lisis):', geminiText);

    // Intentar parsear el JSON de la respuesta de Gemini
    try {
        // Limpiar el texto de Gemini para asegurar que sea JSON v√°lido
        // Busca el primer '{' y el √∫ltimo '}' para extraer el JSON
        const jsonString = geminiText.substring(geminiText.indexOf('{'), geminiText.lastIndexOf('}') + 1);

        geminiResponseJson = JSON.parse(jsonString);

        // Validar la estructura m√≠nima de la respuesta de Gemini
        if (!geminiResponseJson || !geminiResponseJson.action) {
             throw new Error("Respuesta de Gemini inesperada o incompleta.");
        }

        action = geminiResponseJson.action;
        // Usar la pregunta de Gemini si est√° presente, de lo contrario usar fallback
        clarificationQuestion = geminiResponseJson.clarificationQuestion || "Lo siento, no entend√≠ bien. ¬øPodr√≠as ser m√°s espec√≠fico?";

    } catch (parseError) {
      console.error("‚ùå Error al parsear o validar el JSON de Gemini (An√°lisis):", parseError);
      console.log("Texto bruto de Gemini:", geminiText);
       // Si falla el parseo o la validaci√≥n, asumimos que necesita clarificaci√≥n
       action = "clarify";
       clarificationQuestion = "Lo siento, ocurri√≥ un error interno al procesar tu solicitud. ¬øPodr√≠as intentar de nuevo?"; // Pregunta de fallback
    }


    // üîç Paso 2: Decidir la acci√≥n basada en la respuesta de Gemini
    if (action === "clarify") {
        // Si Gemini indica que necesita clarificaci√≥n, respondemos con su pregunta
        conversationalResponse = clarificationQuestion;
        propertyResults = []; // No hay resultados de b√∫squeda en este caso

        console.log("üí¨ Gemini requiere clarificaci√≥n:", conversationalResponse);

        return new Response(
          JSON.stringify({ conversationalResponse, propertyResults, action: "clarify", extractedConcepts: geminiResponseJson?.extractedConcepts || [] }), // Incluimos la acci√≥n y conceptos
          {
            status: 200,
            headers: { "Content-Type": "application/json" },
          }
        );

    } else { // action === "search"
        // Si Gemini indica que se puede buscar, construimos la solicitud de b√∫squeda

        const searchQueryParams = geminiResponseJson.filters || {}; // Usamos los filtros proporcionados por Gemini
        const vertexAiSearchQuery = geminiResponseJson.searchQuery || userQuery; // Usamos el searchQuery optimizado o el original

        console.log("üîé Par√°metros de filtro extra√≠dos por Gemini:", searchQueryParams);
        console.log("üìù Query para Vertex AI Search:", vertexAiSearchQuery);

        // Construimos el filtro solo con los par√°metros que Gemini puso en 'filters'
        const filterString = buildVertexAISearchFilter(searchQueryParams);

        const searchRequest = {
          servingConfig: `${dataStoreName}/servingConfigs/default_serving_config`,
          query: vertexAiSearchQuery, // Usamos el query decidido por Gemini
          queryExpansionSpec: { condition: "AUTO" },
          spellCorrectionSpec: { mode: "AUTO" },
          filter: filterString, // Usamos el filtro construido
        };

        console.log(
          "üõ† Enviando b√∫squeda a Vertex AI Search:",
          JSON.stringify(searchRequest, null, 2)
        );

        // Realizamos la b√∫squeda en Vertex AI Search
        const [searchResponse] = await discoveryengineClient.search(
          searchRequest
        );

        // Extraemos los resultados
        propertyResults =
          searchResponse.results
            ?.map((result) => {
              try {
                // Asegurarse de que jsonData existe y es un string antes de parsear
                const rawJson = result.document?.content?.jsonData;
                if (rawJson && typeof rawJson === 'string') {
                   return JSON.parse(rawJson);
                }
                console.warn("‚ö†Ô∏è Resultado de b√∫squeda con jsonData faltante o inv√°lido:", result);
                return null; // Retornar null si jsonData no es v√°lido
              } catch (e) {
                console.error("‚ùå Error parseando resultado de b√∫squeda:", e);
                return null;
              }
            })
            .filter((item) => item !== null) || []; // Filtrar resultados nulos

        console.log(`‚úÖ ${propertyResults.length} propiedades encontradas.`);

        // üß† Paso 3: Creamos una respuesta conversacional usando Gemini (basada en resultados o falta de ellos)
        let conversationalPromptForGemini;

        // Incluimos los conceptos extra√≠dos por Gemini en el prompt para que los considere
        // y damos instrucciones para que mencione rentabilidad/inversi√≥n si son relevantes
        const extractedConceptsSummary = geminiResponseJson.extractedConcepts && geminiResponseJson.extractedConcepts.length > 0
            ? `Key concepts identified: ${geminiResponseJson.extractedConcepts.join(', ')}.`
            : '';


        if (propertyResults.length > 0) {
          conversationalPromptForGemini = `The user's original request was: "${userQuery}". ${extractedConceptsSummary} I performed a search with the query "${vertexAiSearchQuery}" and found ${
            propertyResults.length
          } properties. Here is a summary of the first few results (up to 3) including relevant fields like location, price, rooms, property type, and any information related to concepts like profitability or investment if available in the data. Ensure the summary is concise but highlights key features relevant to the user's original request:
${JSON.stringify(propertyResults.slice(0, 3), null, 2)}

Based on the original request, the identified concepts (like "investment", "profitability", "beach", "coast"), and the search results, generate a friendly, helpful, and conversational response in **Spanish** to the user.
- Summarize the findings, mentioning how many properties were found.
- Highlight relevant properties from the top results in relation to the user's request (e.g., mention location, price, or features).
- If concepts like "investment" or "profitability" were identified in the user's query or extracted concepts, and the search results contain relevant data (like price, potential rental yield, etc.), mention how these properties might be relevant for investment, referencing the data provided.
- Suggest how they might refine their search if needed.`;
        } else {
           conversationalPromptForGemini = `The user's original request was: "${userQuery}". ${extractedConceptsSummary} I performed a search with the query "${vertexAiSearchQuery}" but found no results matching the criteria or query. Generate a friendly conversational message in **Spanish** informing the user that no properties were found for their request. Based on the concepts identified, suggest trying different criteria, clarifying their needs, or asking about different areas or features.`;
        }

         const conversationalResponseGen = await generativeModel.generateContent(
           conversationalPromptForGemini
         );

         // Extraer el texto de la respuesta conversacional, manejando posibles errores
         conversationalResponse = conversationalResponseGen.response?.candidates?.[0]?.content?.parts?.[0]?.text ||
                                  "Lo siento, no pude generar una respuesta conversacional en este momento."; // Fallback

         console.log("üí¨ Respuesta conversacional generada:", conversationalResponse);


        // ‚úÖ Paso 4: Respondemos al frontend
        return new Response(
          JSON.stringify({
            conversationalResponse,
            propertyResults, // Enviamos los resultados al frontend
            action: "search", // Indicamos que se realiz√≥ una b√∫squeda
            extractedConcepts: geminiResponseJson.extractedConcepts || [] // Opcional: pasar conceptos al frontend
          }),
          {
            status: 200,
            headers: { "Content-Type": "application/json" },
          }
        );
    }


  } catch (error) {
    console.error("‚ùå Error general en el endpoint /api/chat:", error);

    // Generamos una respuesta de error conversacional usando Gemini
    try {
      const errorPrompt = `There was a technical issue processing the user's request: "${userQuery}". Generate a friendly, conversational message in **Spanish** apologizing for the inconvenience and asking them to try again later.`;
      const errorResponseGen = await generativeModel.generateContent(
        errorPrompt
      );
      // Extraer el texto de la respuesta de error, manejando posibles errores
      conversationalResponse = errorResponseGen.response?.candidates?.[0]?.content?.parts?.[0]?.text ||
                               "Lo siento, ha ocurrido un error inesperado. Por favor, intenta de nuevo m√°s tarde."; // Fallback

    } catch (genError) {
      console.error("‚ö†Ô∏è Fallo generando respuesta de error conversacional:", genError);
      conversationalResponse =
        "Lo siento, ha ocurrido un error inesperado. Por favor, intenta de nuevo m√°s tarde."; // Fallback final
    }

    return new Response(
      JSON.stringify({
        error: "Internal Server Error",
        conversationalResponse,
        propertyResults: [],
        action: "error" // Indicamos que hubo un error
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
}


// üîß Funci√≥n auxiliar para construir el filtro de Vertex AI Search
// Ahora esta funci√≥n construye el filtro bas√°ndose **√∫nicamente** en los par√°metros
// que Gemini haya decidido incluir en el JSON 'filters'.
function buildVertexAISearchFilter(params) {
  const filters = [];

  // Mapeo de las claves que Gemini puede devolver en 'filters'
  // a los nombres de campo EXACTOS en tu esquema de Vertex AI Search.
  // ASEG√öRATE de que estas claves y nombres de campo coincidan con tu Data Store
  // y con lo que le instruyes a Gemini que devuelva en su campo 'filters'.
  const filterFieldMap = {
      // Ejemplos basados en tu esquema y posibles par√°metros de Gemini:
      tipo_procedimiento: "tipo_procedimiento",
      fase_procedimiento: "fase_procedimiento",
      fase_actual: "fase_actual",
      rooms: "rooms",
      bathrooms: "bathrooms",
      has_parking: "has_parking",
      uso_predominante_inmueble: "uso_predominante_inmueble",
      // A√±ade aqu√≠ otros mapeos si Gemini extrae otros par√°metros filtrables
      // Ejemplo: superficieMin: "superficie_construida_m2",
      // Ejemplo: superficieMax: "superficie_construida_m2",
      // Ejemplo: anoConstruccion: "ano_construccion_inmueble",
      // NOTA: No incluimos municipio_catastro o provincia_catastro aqu√≠ a menos que
      // decidas que Gemini solo los ponga en 'filters' si son muy espec√≠ficos
      // y quieres un filtro estricto. La estrategia actual se apoya m√°s en el query
      // para ubicaciones generales.
       minPrice: "precio_idealista_venta_m2", // A√±adido basado en la l√≥gica de rangos
       maxPrice: "precio_idealista_venta_m2", // A√±adido basado en la l√≥gica de rangos
  };


  for (const key in params) {
    const value = params[key];
    const field = filterFieldMap[key]; // Obtenemos el nombre exacto del campo para el filtro

    if (!field || value === undefined || value === null) continue;

    // Construimos la parte del filtro seg√∫n el tipo de valor y la clave
    if (typeof value === 'number') {
       // L√≥gica para rangos o igualdad de n√∫meros seg√∫n la clave
       if (key === 'minPrice') {
            filters.push(`${field} >= ${value}`);
       } else if (key === 'maxPrice') {
            filters.push(`${field} <= ${value}`);
       } else if (key === 'bedrooms') {
            filters.push(`${field} >= ${value}`); // Filtrar por al menos N habitaciones
       } else if (key === 'bathrooms') {
            filters.push(`${field} >= ${value}`); // Filtrar por al menos N ba√±os
       }
       // A√±ade l√≥gica para otros campos num√©ricos si Gemini los extrae como n√∫meros exactos
       // else { filters.push(`${field} = ${value}`); }
    } else if (typeof value === 'string') {
       // Para campos string/texto que Gemini identifica como filtrables, usamos ANY()
       // Aseg√∫rate de que el valor del string no sea vac√≠o
       if (value.trim() !== '') {
         filters.push(`${field}: ANY("${value.trim()}")`);
       }
    } else if (typeof value === 'boolean' && key === 'has_parking') {
        // Manejar booleanos si tienes campos booleanos filtrables
        filters.push(`${field} = ${value}`);
    }
    // Si Gemini extrae rangos para alguna clave, necesitar√≠as a√±adir l√≥gica aqu√≠.
    // Ejemplo: { superficie: { min: 50, max: 100 } }
    // else if (typeof value === 'object' && value.min !== undefined && value.max !== undefined) {
    //   const min = typeof value.min === 'number' ? value.min : parseFloat(value.min);
    //   const max = typeof value.max === 'number' ? value.max : parseFloat(value.max);
    //   if (!isNaN(min) && !isNaN(max)) {
    //       filters.push(`${field} >= ${min} AND ${field} <= ${max}`);
    //   } else if (!isNaN(min)) {
    //       filters.push(`${field} >= ${min}`);
    //   } else if (!isNaN(max)) {
    //        filters.push(`${field} <= ${max}`);
    //   }
    // }
  }

   if (filters.length === 0) {
       return ''; // Retorna una cadena vac√≠a si no hay filtros
   }
  return filters.join(" AND ");
}
